<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<title>Iso Grid — 50x50, Scaled Spring/Dump Pairs</title>
<style>
  html,body{margin:0;height:100%;background:#ffffff;overscroll-behavior:contain}
  canvas{display:block;width:100vw;height:100vh;touch-action:none}
  .hud-top{
    position:fixed; left:0; right:0; top:env(safe-area-inset-top);
    display:flex; justify-content:space-between; padding:10px 14px;
    font:14px system-ui,-apple-system,Segoe UI,Roboto,sans-serif; color:#222;
    user-select:none; -webkit-user-select:none
  }
  .hud-bottom{
    position:fixed; left:0; right:0; bottom:calc(8px + env(safe-area-inset-bottom));
    display:flex; flex-wrap:wrap; gap:8px 14px; justify-content:center; align-items:center;
    padding:10px 14px; font:15px system-ui,-apple-system,Segoe UI,Roboto,sans-serif; color:#222;
    background:rgba(255,255,255,.85); backdrop-filter:saturate(1.2) blur(4px);
    border-radius:12px; margin:0 10px; box-shadow:0 2px 8px rgba(0,0,0,.06);
  }
  .btns{position:fixed; left:0; right:0; bottom:calc(64px + env(safe-area-inset-bottom));
        display:flex; gap:12px; justify-content:center}
  button{padding:10px 14px; border:1px solid #e5e6ea; border-radius:12px; background:#fafbff; color:#222}
</style>
</head>
<body>
<canvas id="game"></canvas>

<div class="hud-top">
  <div>Swipe to pan grid • Player centered</div>
  <div id="pos"></div>
</div>

<div class="btns"><button id="reset">↻ Reset</button></div>

<div class="hud-bottom">
  <div><b>Player</b></div>
  <div>Temperature: <span id="pTemp">0</span></div>
  <div>Density: <span id="pDensity">0</span></div>
  <div>Brightness: <span id="pBright">0</span></div>
</div>

<script>
/* ====== Config ====== */
const GRID = { cols: 50, rows: 50 }; // grid size
const STATS = ['Temperature','Density','Brightness'];
const SPRING_RATE = 1;
const DUMP_RATE   = SPRING_RATE;
const SWIPE_THRESHOLD = 24;

// Scale number of spring/dump pairs based on grid size (≈0.001 pairs per cell)
const PAIRS = Math.max(1, Math.round((GRID.cols * GRID.rows) * 0.001));

/* ====== Canvas ====== */
const cvs = document.getElementById('game');
const ctx = cvs.getContext('2d', { alpha:false });
let TILE_W = 64, TILE_H = 32;
let ORIGIN = { x:0, y:0 };
function fit(){
  const dpr=Math.max(1,Math.min(3,devicePixelRatio||1));
  cvs.width=Math.floor(cvs.clientWidth*dpr);
  cvs.height=Math.floor(cvs.clientHeight*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  TILE_W=Math.max(40,Math.min(72,Math.floor(cvs.clientWidth/9)));
  TILE_H=TILE_W/2;
}
addEventListener('resize',fit,{passive:true}); fit();

/* ====== Grid & cells with cached colors ====== */
function makeCell(){ return { Temperature:0, Density:0, Brightness:0, color:"hsl(0,0%,50%)" }; }
function clampStat(v){ return Math.max(-100, Math.min(100, v|0)); }
const cells = Array.from({length:GRID.rows},()=>Array.from({length:GRID.cols},()=>makeCell()));

/* ====== Player (centered) ====== */
const player={Temperature:0,Density:0,Brightness:0};
const pTempEl=document.getElementById('pTemp'), pDensityEl=document.getElementById('pDensity'), pBrightEl=document.getElementById('pBright'), posEl=document.getElementById('pos');
function updateHud(){ posEl.textContent=`focus: (${Math.round(cam.i)},${Math.round(cam.j)})`; pTempEl.textContent=player.Temperature; pDensityEl.textContent=player.Density; pBrightEl.textContent=player.Brightness; }

/* ====== Camera ====== */
const cam={i:25,j:25,ti:25,tj:25,t:1,speed:8/1000}; let ci=cam.i,cj=cam.j;
function clamp(v,min,max){return Math.max(min,Math.min(max,v));}
function inside(i,j){return i>=0&&j>=0&&i<GRID.cols&&j<GRID.rows;}

/* ====== Elements: N spring/dump pairs ====== */
const elements=[];
function randInt(n){return Math.floor(Math.random()*n);}
function randCell(){return {i:randInt(GRID.cols), j:randInt(GRID.rows)};}
function placeElements(){
  elements.length=0;
  const used = new Set();
  const key = (i,j)=>`${i},${j}`;
  for(let p=0;p<PAIRS;p++){
    const stat = STATS[randInt(STATS.length)];
    let s = randCell();
    while(used.has(key(s.i,s.j))) s = randCell();
    used.add(key(s.i,s.j));
    let d = randCell();
    while(used.has(key(d.i,d.j))) d = randCell();
    used.add(key(d.i,d.j));
    elements.push({type:'spring',stat,i:s.i,j:s.j});
    elements.push({type:'dump',stat,i:d.i,j:d.j});
  }
}
placeElements(); updateHud();

/* ====== Input: swipe pans grid ====== */
let start=null;
addEventListener('pointerdown',e=>{const r=cvs.getBoundingClientRect();start={x:e.clientX-r.left,y:e.clientY-r.top};},{passive:true});
addEventListener('pointerup',e=>{
  if(cam.t<1)return;
  const r=cvs.getBoundingClientRect();const end={x:e.clientX-r.left,y:e.clientY-r.top};
  if(!start)return;
  const dx=end.x-start.x,dy=end.y-start.y;const dist=Math.hypot(dx,dy);
  if(dist>=SWIPE_THRESHOLD){const u=dx+dy,v=dy-dx;let si=0,sj=0;if(Math.abs(u)>Math.abs(v))si=Math.sign(u);else sj=Math.sign(v);cam.ti=clamp(cam.i+si,0,GRID.cols-1);cam.tj=clamp(cam.j+sj,0,GRID.rows-1);cam.t=0;}
  start=null;
},{passive:true});

/* ====== Color cache update ====== */
function computeColor(c){
  const L=50+(c.Brightness/2);
  if(c.Density===0&&c.Temperature===0){return `hsl(0,0%,${L}%)`;}
  const hueDensity=180-(c.Density*90/100);
  const hueTemp=90-(c.Temperature*90/100);
  const dx=Math.cos(hueDensity*Math.PI/180)*Math.abs(c.Density);
  const dy=Math.sin(hueDensity*Math.PI/180)*Math.abs(c.Density);
  const tx=Math.cos(hueTemp*Math.PI/180)*Math.abs(c.Temperature);
  const ty=Math.sin(hueTemp*Math.PI/180)*Math.abs(c.Temperature);
  let hue=Math.atan2(dy+ty,dx+tx)*180/Math.PI;if(hue<0)hue+=360;
  return `hsl(${hue.toFixed(1)},50%,${L.toFixed(1)}%)`;
}

/* ====== Per-frame diffusion with caching ====== */
const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
function diffuseAndUpdate(){
  const next=cells.map(row=>row.map(c=>({...c})));
  for(let j=0;j<GRID.rows;j++){
    for(let i=0;i<GRID.cols;i++){
      const C=cells[j][i];
      for(const k of STATS){
        let delta=0;
        for(const [dx,dy] of dirs){
          const ni=i+dx,nj=j+dy;if(!inside(ni,nj))continue;
          const N=cells[nj][ni]; delta+=Math.sign(N[k]-C[k]);
        }
        next[j][i][k]=clampStat(C[k]+delta);
      }
    }
  }
  for(const el of elements){
    const c=next[el.j][el.i];
    c[el.stat]=clampStat(c[el.stat]+(el.type==='spring'?+SPRING_RATE:-DUMP_RATE));
  }
  for(let j=0;j<GRID.rows;j++){
    for(let i=0;i<GRID.cols;i++){
      const old=cells[j][i], n=next[j][i];
      if(old.Temperature!==n.Temperature||old.Density!==n.Density||old.Brightness!==n.Brightness){
        n.color=computeColor(n);
      } else {
        n.color=old.color;
      }
      cells[j][i]=n;
    }
  }
}

/* ====== Drawing ====== */
function elementAt(i,j){for(const e of elements) if(e.i===i&&e.j===j) return e; return null;}
function drawTile(i,j,cell){
  const {x,y}=gridToScreen(i,j);
  ctx.beginPath();
  ctx.moveTo(x,y-TILE_H/2);ctx.lineTo(x+TILE_W/2,y);ctx.lineTo(x,y+TILE_H/2);ctx.lineTo(x-TILE_W/2,y);ctx.closePath();
  ctx.fillStyle=cell.color;ctx.fill();
  ctx.strokeStyle='rgba(0,0,0,.22)';ctx.stroke();
  const el=elementAt(i,j);if(el){const r=Math.max(7,TILE_W*0.14);const tx=x,ty=y-TILE_H*0.55;ctx.beginPath();ctx.arc(tx,ty,r,0,Math.PI*2);ctx.fillStyle=el.type==='spring'?'#2ecc71':'#e74c3c';ctx.fill();ctx.fillStyle='#fff';ctx.font=`${Math.max(10,r)}px system-ui`;ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(el.type==='spring'?'S':'D',tx,ty+0.5);}
}
function gridToScreen(i,j){const x=(i-j)*(TILE_W/2),y=(i+j)*(TILE_H/2);return {x:ORIGIN.x+x,y:ORIGIN.y+y};}
function drawPlayerAtCenter(){const cx=cvs.clientWidth/2,cy=cvs.clientHeight/2,h=TILE_H;ctx.beginPath();ctx.moveTo(cx,cy-TILE_H/2-h);ctx.lineTo(cx+TILE_W/2,cy-h);ctx.lineTo(cx,cy+TILE_H/2-h);ctx.lineTo(cx-TILE_W/2,cy-h);ctx.closePath();ctx.fillStyle='#2a7abf';ctx.fill();ctx.beginPath();ctx.moveTo(cx,cy+TILE_H/2-h);ctx.lineTo(cx+TILE_W/2,cy-h);ctx.lineTo(cx+TILE_W/2,cy);ctx.lineTo(cx,cy+TILE_H/2);ctx.closePath();ctx.fillStyle='#1f5f93';ctx.fill();ctx.beginPath();ctx.moveTo(cx,cy+TILE_H/2-h);ctx.lineTo(cx-TILE_W/2,cy-h);ctx.lineTo(cx-TILE_W/2,cy);ctx.lineTo(cx,cy+TILE_H/2);ctx.closePath();ctx.fillStyle='#2770aa';ctx.fill();}

/* ====== Visible region ====== */
function visibleRanges(){const span=Math.ceil((cvs.clientWidth+cvs.clientHeight)/Math.min(TILE_W,TILE_H))+6;const i0=Math.max(0,Math.floor(ci-span)),i1=Math.min(GRID.cols-1,Math.ceil(ci+span));const j0=Math.max(0,Math.floor(cj-span)),j1=Math.min(GRID.rows-1,Math.ceil(cj+span));return {i0,i1,j0,j1};}

/* ====== Render ====== */
function render(){
  const center={x:cvs.clientWidth/2,y:cvs.clientHeight/2};
  const raw={x:(ci-cj)*(TILE_W/2),y:(ci+cj)*(TILE_H/2)};
  ORIGIN.x=center.x-raw.x;ORIGIN.y=center.y-raw.y;
  ctx.clearRect(0,0,cvs.clientWidth,cvs.clientHeight);
  const {i0,i1,j0,j1}=visibleRanges();
  for(let j=j0;j<=j1;j++){for(let i=i0;i<=i1;i++){drawTile(i,j,cells[j][i]);}}
  drawPlayerAtCenter();
}

/* ====== Loop ====== */
let last=performance.now();
function loop(now=performance.now()){
  requestAnimationFrame(loop);
  const dt=Math.min(33,now-last);last=now;
  if(cam.t<1){const dist=Math.hypot(cam.ti-cam.i,cam.tj-cam.j);const k=(cam.speed*dt)/Math.max(0.0001,dist);const step=Math.min(1-cam.t,k);ci=cam.i+(cam.t+step)*(cam.ti-cam.i);cj=cam.j+(cam.t+step)*(cam.tj-cam.j);cam.t+=step;if(cam.t===1){cam.i=cam.ti;cam.j=cam.tj;ci=cam.i;cj=cam.j;}updateHud();}else{ci=cam.i;cj=cam.j;}
  diffuseAndUpdate(); render();
}
loop();

/* ====== Reset ====== */
document.getElementById('reset').onclick=()=>{
  for(let j=0;j<GRID.rows;j++)for(let i=0;i<GRID.cols;i++)cells[j][i]=makeCell();
  placeElements();
  cam.i=cam.ti=Math.floor(GRID.cols/2); cam.j=cam.tj=Math.floor(GRID.rows/2); cam.t=1; ci=cam.i; cj=cam.j;
  updateHud();
};
</script>
</body>
</html>